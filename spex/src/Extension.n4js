import {ProcessorState} from "InputProcessor";
import {InputSource} from "InputSource";
import {Block} from "Nodes";
import {Document} from "Nodes";
import {Element} from "Nodes";
import {ElementType} from "Nodes";
import {Inline} from "Nodes";
import {Paragraph} from "Nodes";


export public class ExtensionContext {

	@Final
	public indentLevel: int;

	@Final
	public currentElement: Element;

	@Final
	public processorState: ProcessorState;

	@Final
	public inputSource: InputSource;

	constructor(@Spec spec: ~i~this) {}

	public get line(): string {
		return this.inputSource.line;
	}

	public get restOfLine(): string {
		return this.inputSource.restOfLine;
	}
}

export public interface ~ElementProvider {
	/**
	 * Creates the element.
	 */
	createElement(context: ExtensionContext): Element

	/**
	 * Close element previously created with createElement. This method is only called if ctrlEnd returns not undefined.
	 */
	closeElement(element: Element, context: ExtensionContext)
}

export public interface ~Extension extends ElementProvider {

	/**
	 * Name of extension.
	 */
	get name(): string

	/**
	 * True if extension can be referenced by name (followed by command suffix, ":" by default).
	 * E.g., if name is "INFO", if refByName is true, the extension is used via "INFO:".
	 */
	get refByName(): boolean

	/**
	 * Returns element type.
	 */
	get elementType(): ElementType
	
	/**
	 * Control-character(s) which is used to identify whether ctrlMatch is called for further evaluation. 
	 * If ctrlStart is undefined or empty, the extension can only be referenced by name. The returned
	 * character must be of Categegory "OTHER".
	 */
	get ctrlStart(): string

	/**
	 * Called if ctrlStart is found by lexer. This method is called with current line (starting with ctrlStart).
	 * It returns the length of the match, if any, or 0 otherwise. If multiple extension
	 * match, the one with the longer match one is chosen. 
	 */
	matchCtrlStart(line: string): int

	/**
	 * Control-character(s) which is used to identify whether ctrlMatchEnd is called for further evaluation. 
	 * If ctrlEnd is undefined or empty, the extension can only be referenced by name or doesn't need an end.
	 * Note that only extensions are queried which have been started (and not yet ended).
	 */
	get ctrlEnd(): string

	/**
	 * Called if ctrlEnd is found by lexer. This method is called with current line (starting with ctrlEnd).
	 * It returns the length of the match, if any, or 0 otherwise. Only the last started (but not yet ended)
	 * extension is called. All inline extensions automatically end at end of line.
	 */
	matchCtrlEnd(line: string): int

	
}

/**
 * Default implementation of Extension.
 */
export public abstract class AbstractExtension implements Extension {

	/** Returns false by default. */
	@Override
	public get refByName(): boolean {
		return false
	}

	/** Returns undefined by default, i.e., extension cannot be referenced by control sequence. */
	@Override
	public get ctrlStart(): string {
		return undefined
	}

	/** Returns 0 by default. */
	@Override
	public matchCtrlStart(line: string): int {
		return 0
	}

	/** Returns undefined by default, i.e., extension has no explicit end character. */
	@Override
	public get ctrlEnd(): string {
		return undefined
	}

	/**
	 * Returns 0 by default. 
	 */
	@Override
	public matchCtrlEnd(line: string): int {
		return 0
	}

	
	/**
	 * Does nothing by default.
	 */
	@Override
	public closeElement(element: Element, context: ExtensionContext) {
		// nothing by default
	}

}

export public class NamedBlockCommand extends AbstractExtension {

	@Override @Final
	public name: string;
	constructor(name: string) {
		this.name = name;
	}

	@Override
	public get refByName(): boolean {
		return true
	}
	
	@Override
	public get elementType(): ElementType {
		return ElementType.BLOCK
	}
	
	/**
	 * Creates element with name and appends it to the parent element with given indentation.
	 */
	@Override
	public createElement(context: ExtensionContext): Element {
		return new Block(this.name, context.indentLevel+1, context.currentElement);
	}
	

}


export public class InlineFormatting extends AbstractExtension {
	
	@Final ctrlChar: string;
	@Override
	@Final public name: string;
	
	constructor(ctrlChar: string, name: string) {
		this.ctrlChar = ctrlChar;
		this.name = name;
	}
	
	@Override
	public get elementType(): ElementType {
		return ElementType.INLINE
	}
	
	@Override
	public get ctrlStart(): string {
		return this.ctrlChar;
	}
	@Override
	public get ctrlEnd(): string {
		return this.ctrlChar;
	}
	
	@Override
	public matchCtrlStart(line: string): int {
		if (line.startsWith(this.ctrlStart)) {
			return 1;
		}
		return 0;
	}

	@Override
	public matchCtrlEnd(line: string): int {
		return this.matchCtrlStart(line);
	}

	@Override
	public createElement(context: ExtensionContext): Element {
		return new Inline(this.name, context.indentLevel, context.currentElement);
	}
}

export public class DocumentHandler extends AbstractExtension {
	@Override
	public get name(): string {
		return "p";
	}
	@Override
	public createElement(context: ExtensionContext): Element {
		return new Document(); 
	}
	
	@Override
	public get elementType(): ElementType {
		return ElementType.BLOCK;
	}
}

export public class ParagraphHandler extends AbstractExtension {
	@Override
	public get name(): string {
		return "p";
	}
	@Override
	public createElement(context: ExtensionContext): Element {
		return new Paragraph("p", context.indentLevel, context.currentElement);
	}
	
	@Override
	public get elementType(): ElementType {
		return ElementType.PAR
	}
}

export public class PreformattedHandler extends AbstractExtension {
	@Override
	public get name(): string {
		return "pre";
	}
	@Override
	public createElement(context: ExtensionContext): Element {
		return new Paragraph("pre", context.indentLevel, context.currentElement);
	}
	
	@Override
	public get elementType(): ElementType {
		return ElementType.PAR
	}
}